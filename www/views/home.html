<div id="home">
	<div class="intro clearfix">
		<div class="welcome">
			<h2>Ever dreamed of a better alternative to current web tools?
				<em>You've come to the right place!</em></h2>
			<p>AXR is a new platform for creating web sites and applications,
				redesigned from the ground up to enable modern user experiences.
				The web you love, but <strong>better</strong>.</p>

			<a href="/about/manifesto" class="uiButton inline gray manifesto">
				<span class="inner">
					<span class="icon"></span>
					read the manifesto
				</span>
			</a>
			<a href="/about/features" class="uiButton inline go">
				<span class="inner">
					<span class="icon"></span>
					Learn more
				</span>
			</a>
		</div>

		<a class="presentation" href="https://www.youtube.com/watch?v=QwLY2gYyTFE"
			target="_blank"><span>Featured presentation</span></a>
	</div>
	<hr class="block_separator" />

	{{#release}}
		<div class="getit clearfix">
			<div class="info">
				<h2>Get an early sneak-peek:</h2>
				<p>Our prototype is already capable of doing many of the cool
					features of HSS. It's not a full browser yet, but it allows
					you to start experimenting right now with the web language
					of the future.</p>
			</div>
			<div class="download">
				<a href="{{release._file.url}}" class="uiButton get big">
					<span class="inner">
						<span class="big">Download now</span>
						<span class="version">{{release.version}}</span>
						<span class="for">for {{release._file._os}}</span>
						<span class="bomb"></span>
					</span>
				</a>
				<a class="morestuff" href="http://docs.axr.vg">API docs</a>
				<a class="morestuff" href="/downloads">All downloads</a>
			</div>
		</div>
		<hr class="block_separator" />
	{{/release}}

	<div class="social clearfix">
		<div class="left">
			<h2>Latest blog posts:</h2>
			<ul class="blog">
				{{#blog_posts}}
					<li>
						<span class="icon"></span>
						<span class="post">
							<a href="{{permalink}}">{{title}}</a>
							<time datetime="{{ctime_str_Ymd}}">({{ctime_str_Ymd}})</time>
						</span>
					</li>
				{{/blog_posts}}
			</ul>

			<hr />

			<h2>Social Media <span>Follow us on:</span></h2>
			<a href="https://twitter.com/#!/AXRProject" target="_blank"
				class="social_media twitter">Twitter</a>
			<a href="https://facebook.com/AXRProject" target="_blank"
				class="social_media facebook">Facebook</a>
			<a href="https://plus.google.com/105865857923622443169" target="_blank"
				class="social_media google_plus">Google+</a>
			<a href="https://www.youtube.com/user/axrproject" target="_blank"
				class="social_media youtube">YouTube</a>
		</div>

		<div class="github">
			<h2>Most recent GitHub activity:</h2>
			<div class="box">
				<div class="icon">
					<div class="extra_0"></div>
					<div class="extra_1"></div>
				</div>
				<div class="nested_0">
					<ul class="_github_activity">
						<li><div class="inner">Loading...</div></li>
					</ul>
				</div>
			</div>
		</div>
	</div>
	<hr class="block_separator" />

	<div class="hss_features clearfix">
		<div class="features_menu" id="hss_features_menu">
			<h2>Features of HSS</h2>
			<div class="header"></div>
			<ul class="content">
				<li class="selected" data-section-name="hierarchical">
					<a href="#">
						<span class="header"></span>
						<span class="content">Hierarchical</span>
						<span class="footer"></span>
					</a>
				</li>
				<li data-section-name="object_oriented">
					<a href="#">
						<span class="header"></span>
						<span class="content">Object oriented</span>
						<span class="footer"></span>
					</a>
				</li>
				<li data-section-name="modular">
					<a href="#">
						<span class="header"></span>
						<span class="content">Modular</span>
						<span class="footer"></span>
					</a>
				</li>
				<li data-section-name="expressions">
					<a href="#">
						<span class="header"></span>
						<span class="content">Expressions</span>
						<span class="footer"></span>
					</a>
				</li>
				<li data-section-name="functions">
					<a href="#">
						<span class="header"></span>
						<span class="content">Functions</span>
						<span class="footer"></span>
					</a>
				</li>
				<li data-section-name="references">
					<a href="#">
						<span class="header"></span>
						<span class="content">References</span>
						<span class="footer"></span>
					</a>
				</li>
				<li data-section-name="filters">
					<a href="#">
						<span class="header"></span>
						<span class="content">Filters</span>
						<span class="footer"></span>
					</a>
				</li>
				<li data-section-name="structural_independence">
					<a href="#">
						<span class="header"></span>
						<span class="content">Structural Independence</span>
						<span class="footer"></span>
					</a>
				</li>
				<li data-section-name="layout">
					<a href="#">
						<span class="header"></span>
						<span class="content">Layout</span>
						<span class="footer"></span>
					</a>
				</li>
			</ul>
			<div class="footer"></div>
		</div>
		<div class="features_content" id="hss_features_content">
			<div class="selected" data-section-name="hierarchical">
				<p>Instead of writing longer and longer selector chains, the
				rules (the selectors + the block with the properties) can be
				nested inside each other. If the content in the XML file is
				a tree of elements, why not apply styles using a tree as
				well? It is both clearer and has better performance, since
				not all elements have to be matched against each selector.</p>
				<h3>CSS:</h3>
<pre><code data-language="css">books { }
books > book{ }
books > book > cover { }</code></pre>

					<h3>HSS:</h3>
<pre><code data-language="hss">books {
	book {
		cover { }
	}
}</code></pre>
			</div>
			<div data-section-name="object_oriented">
				<p>Instead of dealing with an ever growing, plain list of
				properties, in HSS you use objects that encapsulate a group
				of related values, just as objects encapsulate related
				functionality in traditional object oriented programming
				languages.</p>
				<h3>CSS:</h3>
<pre><code data-language="css">selector
{
	border-size: 1px;
	border-color: #F00;
	border-style: solid;
}</code></pre>

				<h3>HSS:</h3>
<pre><code data-language="hss">selector
{
	border: @line {
		size: 1;
		color: #F00;
	};
}</code></pre>
			</div>
			<div data-section-name="modular">
				<p>You can give any HSS object a name, and reuse it as
				needed. You can make "presets" and apply them to the
				selected object(s) and then even override any property as
				needed.</p>
				<p>For example:</p>
<pre><code data-language="hss">@linearGradient boxBg
{
	startColor: #F;
	endColor: #0;
	endY: 100%;
}

@container box
{
	width: 150;
	height: 100;
	background: boxBg;
}

selector chain
{
	isA: box;
}</code></pre>
			</div>
			<div data-section-name="expressions">
				<p>Anywhere a number is accepted as a value, you can also
				use an expression. This is especially useful when you want
				to mix fixed-width elements with fluid ones. For example,
				when you have a sidebar 150 point wide, how wide is the
				rest? Answer: 100% - 150.</p>
				<p>For example:</p>
<pre><code data-language="hss">sidebar
{
	width: 150;
}

content
{
	width: 100% - 150;
}</code></pre>
			</div>
			<div data-section-name="functions">
				<p>Functions like min(), max() or round() help you control the
				dimensions of your elements in fluid environments, without
				the need for countless properties such as min-width or
				max-height in CSS. The function will always return the
				appropriate value depending on the parameters.</p>
				<p>For example:</p>
<pre><code data-language="hss">selector
{
	// make it 20% the width of the parent, but at
	// least 150 points wide and at most 400 points
	width: min(150, max(400, 20%));
}</code></pre>
			</div>
			<div data-section-name="references">
				<p>Many times it is very useful to be able to refer to a
				property of another element to do some calculations, for
				example. Imagine a site with a sidebar and content area, for
				example. You want to make the content area as wide as the
				whole page minus the sidebar, which is flexible. So you'd do
				something like this:</p>
<pre><code data-language="hss">page
{
	sidebar
	{
		// like in the previous example
		width: min(150, max(400, 20%));
	}

	content
	{
		width: 100% - ref(width of sidebar);
	}
}</code></pre>
			</div>
			<div data-section-name="filters">
				<p>Filters are like pseudo-selectors in CSS but with a
				completely overhauled selection system. Since HSS has scope,
				the selectors are read from left to right. You select
				elements based on the name, for example, and then you filter
				that selection down to the elements you really want. There
				are a lot of them to cover all the different needs, so check
				out the docs.</p>
<pre><code data-language="hss">// selects the first of the elements named foo
foo:first { }
// selects the elements named foo that are first inside
// their parent
foo:firstChild { }
// selects bar elements, then return the 2nd, 4th, 6th, etc
bar:even { }
// selects baz elements whose width is greater than 500
baz:(width > 500) { }
// selects qux elements whose title attribute start
// with "Welcome"
qux:[title:startsWith("Welcome")] { }</code></pre>
			</div>
			<div data-section-name="structural_independence">
				<p>The structure of the content is intrinsic to its meaning,
				it should NEVER be altered just because of some stylistic
				requirements. Therefore, in HSS you can freely manipulate
				the content tree to fit whatever structure you need to
				achieve your visual layout.</p>
<pre><code data-language="hss">root
{
	// wrap the element called "navigation" in a new
	// "header" element
	#wrap(navigation) header
	{
		// supposing myMenuPreset has been defined elsewhere
		navigation { isA: myMenuPreset; }
	}
	// wrap everything that is not "header" or "footer" in a
	// new "content" element
	#wrap(!(header, footer)) content
	{
		// change the order of the items
		#move element2 { /*etc*/ }
		#move element1 { /*etc*/ }
		#move element3 { /*etc*/ }
	}
	// create a new footer, if not already there
	#ensure footer
	{
		// create a new search box, assuming the object has been
		// defined elsewhere
		#new search { isA: searchBox; }
	}
}</code></pre>
			</div>
			<div data-section-name="layout">
				<p>A new box model, combined with most of the other features
				in this list, provide an awesome new way of doing layout,
				more suited to how designers think. Instead of floating,
				pushing and otherwise bang your head against the wall when
				laying out your elements on the page, you use alignX and
				alignY to set alignment points. These will determine the
				position of the elements in the page, which will flow inside
				of their parents, balancing themselves out when more than
				one tries to align itself on that specific point. It sounds
				more complicated than it really is, so here come some
				examples:</p>
<pre><code data-language="hss">// align foo to the right horizontally
foo { alignX: left; }
// align bar at the middle vertically
bar { alignY: middle; }
// place baz with it's right edge 30 points to the left
// of the center of its parent, without affecting other
// elements
baz
{
	anchorX: 100%;
	alignX: 50% - 30;
	flow: no;
}
// align all elements *inside* qux at the middle vertically,
// and lay them out from top to bottom instead of left
// to right
qux
{
	contentAlignY: middle;
	direction: ttb;
}</code></pre>
			</div>
		</div>
	</div>
</div>

{{^_ajax}}
	<script>
		withApp(function (App)
		{
			App.pageEvent.trigger('load_init', '/home');
			App.pageEvent.trigger('load', '/home');
		});
	</script>
{{/_ajax}}
